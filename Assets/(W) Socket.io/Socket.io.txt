(1)
(Socket.io)
(Backend)
(Socket.js)
import { Server } from 'socket.io';
import http from 'http';
import express from 'express';

const app = express();

const server = http.createServer(app);
const io = new Server(server, {
    cors: {
        origin: ["http://localhost:3000"],
        methods: ["GET", "POST"],
    },
});

io.on("connection", (socket) => {
    console.log("User connected", socket.id);

    // Socket.on() is used to listen to events. Can be used for both on client and server side rendering.
    socket.on("disconnect", () => {
        console.log("User disconnected", socket.id);
    });
});

export {app, io, server};



(2)
(Frontend)
(SocketContext.jsx)
npm install socket.io-client
import { useEffect, useState, createContext } from "react";
import {useAuthContext} from './AuthContext';
import io from "socket.io-client";

export const SocketContext = createContext();

export const SocketContextProvider = ({children}) => {
    const [socket,setSocket] = useState(null);
    const [onlineUsers, setOnlineUsers] = useState([]);
    const {authUser} = useAuthContext();

    useEffect(() => {
        if(authUser) {
            const socket = io("http://localhost:5000", {
                query:{
                    userId: authUser._id
                }
            });

            setSocket(socket);

            return () => socket.close();
        } else {
            if (socket) {
                socket.close();
                setSocket(null);
            }
        }
    },[]);

    return <SocketContext.Provider value={{socket, onlineUsers}}>{children}</SocketContext.Provider>;
};



(3)
(Online feature)
(Socket.js)
import { Server } from 'socket.io';
import http from 'http';
import express from 'express';

const app = express();

const server = http.createServer(app);
const io = new Server(server, {
    cors: {
        origin: ["http://localhost:3000"],
        methods: ["GET", "POST"],
    },
});

const userSocketMap = {};
// {userId: socketId}
io.on("connection", (socket) => {
    console.log("User connected", socket.id);

    const userId = socket.handshake.query.userId;
    if (userId != "undefined") userSocketMap[userId] = socket.id;

    // io.emit() is used to send events to all connected clients.
    io.emit("getOnlineUsers", Object.keys(userSocketMap));

    // Socket.on() is used to listen to events. Can be used for both on client and server side rendering.
    socket.on("disconnect", () => {
        console.log("User disconnected", socket.id);
        delete userSocketMap[userId];
        io.emit("getOnlineUsers", Object.keys(userSocketMap));
    });
});

export {app, io, server};


(SocketContext.jsx)
import { useEffect, useState, createContext, useContext } from "react";
import {useAuthContext} from './AuthContext';
import io from "socket.io-client";

export const SocketContext = createContext();

export const useSocketContext = () => {
    return useContext(SocketContext);
};

export const SocketContextProvider = ({children}) => {
    const [socket,setSocket] = useState(null);
    const [onlineUsers, setOnlineUsers] = useState([]);
    const {authUser} = useAuthContext();

    useEffect(() => {
        if(authUser) {
            const socket = io("http://localhost:5000", {
                query:{
                    userId: authUser._id
                }
            });

            setSocket(socket);

            // Socket.on() is used to listen to events. Can be used for both on client and server side rendering.
            socket.on("getOnlineUsers", (users) => {
            setOnlineUsers(users);
            });

            return () => socket.close();
        } else {
            if (socket) {
                socket.close();
                setSocket(null);
            }
        }
    },[authUser]);

    return <SocketContext.Provider value={{socket, onlineUsers}}>{children}</SocketContext.Provider>;
};


(Conversation.jsx)
import useConversation from "../../zustand/useConversation.js";
import { useSocketContext } from "../../context/SocketContext.jsx";

const Conversation = ({ conversation, lastIdx, emoji }) => {
	const { selectedConversation, setSelectedConversation } = useConversation();

	const isSelected = selectedConversation?._id === conversation._id;
	const {onlineUsers} = useSocketContext();
	const isOnline = onlineUsers.includes(conversation._id)

	return (
	  <>
		<div className={`flex gap-2 items-center hover:bg-sky-500 rounded p-2 py-1 cursor-pointer ${isSelected ? "bg-sky-500" : ""}`}
		onClick={() => setSelectedConversation(conversation)}>
		  <div className={`avatar ${isOnline ? "online" : ""}`}>
			<div className="w-12 rounded-full">
			  <img src={conversation.profilePic} alt="user avatar" />
			</div>
		  </div>

		  <div className="flex flex-col flex-1">
			<div className="flex gap-3 justify-between">
			  <p className="font-bold">{conversation.fullName}</p>
			  <span className="text-xl">{emoji}</span>
			</div>
		  </div>
		</div>

		{!lastIdx && <div className="divider my-0 py-0 h-1" />}
	  </>
	);
  };

  export default Conversation;


(MessageContainer.jsx)
import Messages from "./Messages";
import MessageInput from "./MessageInput";
import { TiMessages } from "react-icons/ti";
import useConversation from "../../zustand/useConversation.js";
import { useEffect } from "react";
import { useAuthContext } from "../../context/AuthContext.jsx";

const MessageContainer = () => {
	const { selectedConversation, setSelectedConversation } = useConversation();

	useEffect(() => {
		// cleanup function (unmounts)
		return () => setSelectedConversation(null);
	}, [setSelectedConversation]);

	return (
		<div className='md:min-w-[450px] flex flex-col'>
            {!selectedConversation ? (
              <NoChatSelected />
            )  : (
			   <>
				{/* Header */}
				<div className='bg-slate-500 px-4 py-2 mb-2'>
					<span className='label-text'>To:</span> <span className='text-gray-900 font-bold'>{selectedConversation.fullName}</span>
				</div>
				<Messages />
				<MessageInput />
			</>
            )}
		</div>
	);
};
export default MessageContainer;

const NoChatSelected = () => {
	const {authUser} = useAuthContext()
	return (
		<div className='flex items-center justify-center w-full h-full'>
			<div className='px-4 text-center sm:text-lg md:text-xl text-gray-200 font-semibold flex flex-col items-center gap-2'>
				<p>Welcome üëã {authUser.fullName} ‚ùÑÔ∏è</p>
				<p>Select a chat to start messaging</p>
				<TiMessages className='text-3xl md:text-6xl text-center' />
			</div>
		</div>
	);
};



(4)
(Real time message)
(Socket.js)
export const getReceiverSocketId = (receiverId) => {
    return userSocketMap[receiverId];
}


(message.controllers.js)
		// SOCKET FUNCTIONLAITY WILL GO HERE.
		const receiverSocketId = getReceiverSocketId(receiverId);
		if(receiverSocketId) {
			// io.to(<socketid>).emit() is used to send events to specific client.
			io.to(receiverSocketId).emit("newMessage",newMessage)
		}


(useListenMessages.js)


(useListenMessages.js)
import notificationSound from "../assets/sounds/notification.mp3";
	useEffect(() => {
		socket?.on("newMessage", (newMessage) => {
            newMessage.shouldShake = true;
            const sound = new Audio(notificationSound);
			sound.play();
			setMessages([...messages, newMessage]);
		});

		return () => socket?.off("newMessage");
	}, [socket, setMessages, messages]);
};


(Messages.jsx)
import useListenMessages from "../../hooks/useListenMessages";
useListenMessages();


(Message.jsx)
const shakeClass = message.shouldShake ? "shake" : "";
<div className={`chat-bubble text-white ${bubbleBgColor} ${shakeClass} pb-2`}>{message.message}</div>
